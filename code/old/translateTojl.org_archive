#    -*- mode: org -*-


Archived entries from file /home/marcelovmaciel/Drive/Org/Projects/partisan-learning/code/translateTojl.org


* Parties attributes
:PROPERTIES:
:ARCHIVE_TIME: 2021-07-26 seg 18:56
:ARCHIVE_FILE: ~/Drive/Org/Projects/partisan-learning/code/translateTojl.org
:ARCHIVE_OLPATH: The initial condition
:ARCHIVE_CATEGORY: translateTojl
:END:
+ Party platform which is equal to \(k\) positions in \(n\) issues;
+ Vote share;
#+BEGIN_SRC jupyter-julia :session jl
mutable struct AnchoredParty{n} <: abm.AbstractAgent
    id::Int
    pos::NTuple{n,Float64}
    share::Float64
    end

mutable struct UniformParty{n} <: abm.AbstractAgent
    id::Int
    pos::NTuple{n,Float64}
    share::Float64
end

function AnchoredParty(id,n,k,share)
    generate_party_ideology(n,k) = voter_issue_generation(n,k)
    AnchoredParty{n}(id, generate_party_ideology(n,k), 0.)
    end

function UniformParty(id,n,k,share)
    generate_party_ideology(n,k) =  rand(dst.Uniform(first(k), last(k)),n,1)
    UniformParty{n}(id, generate_party_ideology(n,k), 0.)
    end
#+END_SRC

#+RESULTS:
: UniformParty



* The stepping
:PROPERTIES:
:ARCHIVE_TIME: 2021-07-31 sáb 18:11
:ARCHIVE_FILE: ~/Drive/Org/Projects/partisan-learning/code/translateTojl.org
:ARCHIVE_CATEGORY: translateTojl
:END:
- Campaign procedure:
  1. Parties send signal about issue salience to all voters;
  2. Voters update, probabilistically, their salience;
  3. Voters interact and update their most salient positions;
  4. Parties test a random position within a range of their current position.
     Note two things:
     a) They keep other parties positions fixed;
     b) Their calculus takes into account the current issue/weight distributions!
  Repeat that ~c~ times.

- Election procedure
  1. Parties pick the position with highest vote share they found in their campaign exploration;
  2. Determine vote shares;


#+BEGIN_SRC jupyter-julia :session jl :tangle yes

voters = let vs = Vector{Voter}(undef,v)
    for i in 1:v
    vs[i] = (@inbounds m[i])
    end
    vs
end;

#+END_SRC

#+RESULTS:


#+BEGIN_SRC jupyter-julia :session jl
map(x->x.id,parties)
#+END_SRC

#+RESULTS:
#+begin_example
10-element Vector{Int64}:
 3001
 3002
 3003
 3004
 3005
 3006
 3007
 3008
 3009
 3010
#+end_example


#+BEGIN_SRC jupyter-julia :session jl
partiesd = DICT.Dictionary(map(x->x.id,parties), parties)
#+END_SRC

#+RESULTS:
#+begin_example
10-element Dictionaries.Dictionary{Int64, AnchoredParty{2}}
 3001 │ AnchoredParty{2}(3001, (1.3678081600321725, 7.741170125513275), [2.5806…
 3002 │ AnchoredParty{2}(3002, (6.015582736790778, 0.2753375314837214), [2.0189…
 3003 │ AnchoredParty{2}(3003, (6.8343974742820475, 6.5590358120887675), [1.769…
 3004 │ AnchoredParty{2}(3004, (3.238038371904535, 2.3204215155130026), [2.0282…
 3005 │ AnchoredParty{2}(3005, (0.6422528179988003, 6.853336958559263), [1.8543…
 3006 │ AnchoredParty{2}(3006, (6.8754238216616415, 6.535142906700607), [0.6717…
 3007 │ AnchoredParty{2}(3007, (3.305608814948963, 1.4737667593019612), [5.2194…
 3008 │ AnchoredParty{2}(3008, (1.9931873177365187, 4.760477631494176), [7.5932…
 3009 │ AnchoredParty{2}(3009, (2.7857917197510496, 7.698156977765338), [5.9841…
 3010 │ AnchoredParty{2}(3010, (3.2032211047739256, 2.4193548939540523), [3.477…
#+end_example


#+BEGIN_SRC jupyter-julia :session jl
function get_voters_withinradius(p,voters)::Vector{Voter}
    voters[(a->dist.euclidean(a.id_pos,p.id_pos)).(voters) .<  m.properties[:r]]
end
#+END_SRC

#+RESULTS:
: get_voters_withinradius (generic function with 1 method)


#+BEGIN_SRC jupyter-julia :session jl
function getparties_spheres(parties,voters)
    map(p->get_voters_withinradius(p, voters), parties)
end
#+END_SRC

#+RESULTS:
: getparties_spheres (generic function with 1 method)

#+BEGIN_SRC jupyter-julia :session jl
prties_spheres = getparties_spheres(partiesd, voters)
#+END_SRC

#+RESULTS:
#+begin_example
10-element Dictionaries.Dictionary{Int64, Vector{Voter}}
 3001 │ Voter[Voter{2}(1, (4.119302019401751, 7.130782637556164), [2.2963938910…
 3002 │ Voter[Voter{2}(1, (4.119302019401751, 7.130782637556164), [2.2963938910…
 3003 │ Voter[Voter{2}(1, (4.119302019401751, 7.130782637556164), [2.2963938910…
 3004 │ Voter[Voter{2}(1, (4.119302019401751, 7.130782637556164), [2.2963938910…
 3005 │ Voter[Voter{2}(1, (4.119302019401751, 7.130782637556164), [2.2963938910…
 3006 │ Voter[Voter{2}(8, (4.963477316081782, 0.03632892282135991), [0.0, 1.456…
 3007 │ Voter[Voter{2}(4, (4.476385112926241, 6.957581596228186), [5.1356612854…
 3008 │ Voter[Voter{2}(2, (5.35547058015174, 7.166775199977851), [8.0, 6.624700…
 3009 │ Voter[Voter{2}(3, (0.0032619883859670296, 7.171590394117873), [4.316061…
 3010 │ Voter[Voter{2}(1, (4.119302019401751, 7.130782637556164), [2.2963938910…
#+end_example


#+BEGIN_SRC jupyter-julia :session jl
function whichsignal(nissues)
    issues = collect(1:nissues)
    pos1 = rand(issues)
    pos2 = rand(issues)
    if pos1 == pos2
        deleteat!(issues, findall(x->x==pos1,issues)) # deletes all elements that have a certain value from an array
        pos2 = rand(issues)
        end
    signals = (positive = pos1 , negative = pos2 )
    end
#+END_SRC

#+RESULTS:
: whichsignal (generic function with 1 method)

#+BEGIN_SRC jupyter-julia :session jl
mapreduce(x-> utility(x, m[3001] ), +, prties_spheres[3001])
#+END_SRC

#+RESULTS:
: -917.3430230475668

If the salience is already the highest the agent will not add the positive signal to it.
If the salience of the other issue is the lowest the agent will not add the negative signal to it.

#+BEGIN_SRC jupyter-julia :session jl
function positive_signalfn(x::Voter, positive_signal_index)
    oldweight = copy(x.weight)
    if x.weight[positive_signal_index] == last(s)
        x.weight[positive_signal_index] = x.weight[positive_signal_index]
    else
        print(x.weight[positive_signal_index])
        x.weight[positive_signal_index] = x.weight[positive_signal_index] + 1
    end
    u = utility(x,m[3001])
    x.weight = oldweight
    return(u)
end

function negative_signalfn(x::Voter, nsi)
    oldweight = copy(x.weight)
    if x.weight[nsi] == first(s)
        x.weight[nsi] += 0
    else
        x.weight[nsi] -= 1
    end
    u = utility(x, m[3001] )
    x.weight = oldweight
    return(u)
end

#+END_SRC

#+RESULTS:
: negative_signalfn (generic function with 1 method)

#+BEGIN_SRC jupyter-julia :session jl
negative_signalfn(m[1],1)
#+END_SRC

#+RESULTS:
: -2.426463558302548

#+BEGIN_SRC jupyter-julia :session jl
signal = whichsignal(2)
#+END_SRC

#+RESULTS:
: (positive = 1, negative = 2)

#+BEGIN_SRC jupyter-julia :session jl

mapreduce(x-> negative_signalfn(x, signal.positive), +, prties_spheres[3001])

#+END_SRC

#+RESULTS:
: -950.2939700133265
